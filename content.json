[{"title":"商周青铜文化和礼乐文明","date":"2017-01-11T12:51:28.000Z","path":"2017/01/11/商周青铜文化和礼乐文明/","text":"商周青铜文化和礼乐文明[toc] 商代的青铜文明与秦汉之后的制度文明，在世界史上十分著名。 探索商代历史的五条途径 张光直 著 《商文明》 传统历史文献《诗经·商颂·玄鸟》：天命玄鸟，降而生商与鸟有关的传说大多出现在沿海地区《史记·殷本纪》：成汤 -&gt; 仲丁 -&gt; 盘庚 青铜器铭文：金文器物类型： 食器，饮酒器装饰艺术：饕餮纹制造技术 卜骨和卜甲19世纪末被发现。钻凿钻出小坑，占卜时炙烤，出现裂纹。甲骨四堂：郭沫若（字鼎堂）、董作宾（字彦堂）、罗振玉（号雪堂）和王国维（号观堂）。 考古学经过科研发掘的价值更高，有地层信息等。重要发现：除安阳殷墟，还有郑州商城，偃师商城等。 董作宾《民国十七年试掘安阳小屯报告》 理论模式史料学中介理论模式概括性发展理论 商代青铜文化中国青铜时代的巅峰。先商时期： 《 史记·殷本纪》 ：“母曰简狄，有娀氏之女，为帝喾次妃。三人行浴，见玄鸟堕其卵，简狄取吞之，因孕，生契。契长而佐禹治水，有功。帝舜……封于商，赐姓子氏”。《 尚书序》 ： “ 自契至成汤八迁。 ”商时期:《 尚书·汤誓》 ：“有夏多罪，天命殛之， ……予畏上帝，不敢不正。”张衡《 西京赋》 ：“殷人屡迁，前八后五。”古本《 竹书纪年》 ：“自盘庚迁殷，至纣之灭，二百七十三年更不徙都。” 偃师商城与郑州商城的关系：一种观点：《商代史论纲》宋镇豪 西周礼乐文明武王伐纣——周公东征——成康之治——昭王 南征与穆王游行——国人暴动与共和行政—— 宣王中兴——西周覆灭 西周典制封建制：《左传·僖公二十四年》： “周公……封建亲戚，以藩屏周。”《荀子·儒效》： “〔周公〕兼制天下，立七十一国，姬姓独居五十三 人焉。”宗法制：宗法是中国古代社会利用血缘关系对族人进行管理的 基本原则，其主要内容是嫡长子继承制。商代已有嫡 长继承的雏形。西周时期，宗法发展成为系统制度。礼乐制度：在各种典礼、仪式中，不同社会地位的参与者都有各 自不同的、严格的具体行为规范。通过这些行为规范 区别尊卑、亲疏、贵贱、贤愚等社会范畴，是周代礼 制的基本精神。 夏商周三代关系夏商周三代是并列关系，只是不同时期强盛情况不同。 夏商周三代都属于复合制国家结构，只是其发展的程度，商 代强于夏代，周代又强于商代。在夏代，其复合制国家的特 征主要是由夏王乃“天下共主”来体现的；而到了商代，除 了商王取代夏而成为新的“天下共主”外，其复合制国家结 构更主要是由“内服”和“外服”制来构成的；到了周代， 周王又取代商而为“天下共主”，其复合制国家结构则通过 大规模的分封和分封制而达到了鼎盛。 ——王震中《中国古代国家的起源与王权的形成》","tags":[{"name":"历史","slug":"历史","permalink":"http://yoursite.com/tags/历史/"},{"name":"课堂笔记","slug":"课堂笔记","permalink":"http://yoursite.com/tags/课堂笔记/"}]},{"title":"给win32程序加上图标","date":"2016-06-16T15:38:16.000Z","path":"2016/06/16/给win32程序加上图标/","text":"引言最近写了一个小程序，想给给生成的exe可执行文件加上图标。于是就去stackoverflow查了下，果然已经有人给出了方案。 方法我用的是Visual Studio 2012。方法非常简单。其他的IDE应该也类似。解决方案，右键 -&gt; 添加 -&gt; 资源然后选择icon，导入这是系统会查找目录下的bmp，jpg等图片。但是这几种图片加载后好像会有问题。我们下拉选择框，会出现ico文件。实在是愚蠢的GUI。然后选择你要用的ico文件。这样vs就会为你生成所有需要的东西（resource.h *.rc *.ico）。此时再编译运行，就可以了。如果没有ico文件，google jpg to ico就可以找到在线转换网站。","tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"}]},{"title":"进化出来的“蒙娜丽莎”","date":"2016-06-16T14:21:24.000Z","path":"2016/06/16/进化出来的蒙娜丽莎/","text":"引言本算法并非原创，原作者的文章在这里。本文的程序用的是C++,参考了原作者的C#版本，以及Gabry的C++版本。 简介采用遗传算法，用多边形来拟合出一幅图片。效果如图：可以看到拟合的效果还是非常好的。我们先介绍一下遗传算法Genetic Algorithm下面是维基百科的定义 In the field of artificial intelligence, a genetic algorithm (GA) is a search heuristic that mimics the process of natural selection. This heuristic (also sometimes called a metaheuristic) is routinely used to generate useful solutions to optimization and search problems. 这个算法，就是模拟生物杂交，自交，变异，以及自然选择的过程，来优化生物的DNA，最终来接近最优解的过程。遗传算法属于元启发式算法，我们不用去管算法的繁琐细节。只需要设置好遗传和变异的参数，再写一个自然选择的函数，剩下来就等待大自然的鬼斧神工了。 算法实现我第一次看到这个算法觉得很惊艳。虽然马上就要考试了，我还是花了周六一天用C++重写了这个程序。然而并没有写GUI，图片格式也只支持24位bmp位图。（╯－＿－）╯╧╧等有时间的话加上其他的东西吧。 12345678910111213class DNAImage&#123;private: typedef list&lt;DNAPolygon&gt; PolyList; typedef PolyList::iterator PolyIter; PolyList _polyList; bool addPoly(); bool delPoly(); bool movePloy();public: bool imageMutate(); void renderImage();&#125; 在DNAImage中，_polyList是已有的多边形的一个列表。也就是DNA。imageMutate函数是进化函数，随机的增加删除或移动一个多边形。同样还有DNAPolygon，DNAPoint类，分别随机地增加（减少）多边形中的点，随机地移动该点。然后进化一次后，和进化前的图片比较与原图的差异度，如果差异较小，就保留进化后的图片，否则舍弃掉。这样经过数万代，数十万代的进化后就可以得到一张接近原图的low poly风格的图片。 总结我最开始打算用python，但是速度真的是无法忍受。C++版本（release版）速度还可以。然而我好像没有使用GPU，这种大量重复运算应该是很适合GPU的。然而我并不会。另外我虽然和原作者用了相同算法，甚至参数都调的几乎一样，然而效果比原作者的却差一些。（迷之差异）。源码在我的github上。最后放上一些图片。","tags":[{"name":"遗传算法","slug":"遗传算法","permalink":"http://yoursite.com/tags/遗传算法/"},{"name":"图像处理","slug":"图像处理","permalink":"http://yoursite.com/tags/图像处理/"}]},{"title":"Alpha-beta pruning","date":"2016-05-27T02:43:13.000Z","path":"2016/05/27/Alpha-beta-pruning/","text":"IntroductionAlpha-beta pruning is the standard searching procedure used for 2-person perfect-information zero sum games. defination: A position p The value of a position $p$, $f(p)$ is a numerical value computed from evaluating p. Value is computed from the root player’s point of view. Positive values mean in favor of the root player. Negative values mean in favor of the opponent. Since it’s a zero sum game, from the opponent’s view, the value can be assigned $-f(p)$ A terminal position: a position whose value can be known. A position $p$ has $d$ legal moves, $p_1, p_2, \\cdots , p_d$ Tree node numberinglike the picture above. This is called Dewey decimal system Mini-max formulation $$F(p) = \\cases { {f(p)} &amp; {if d = 0} \\\\ {\\max \\lbrace G(p_1), G(p_2) , \\cdots, G(p_d) \\rbrace } &amp; {if d &gt; 0} }$$$$G(p) = \\cases { {f(p)} &amp; {if d = 0} \\\\ {\\min \\lbrace F(p_1), F(p_2) , \\cdots, F(p_d) \\rbrace } &amp; {if d &gt; 0} }$$we can call two players Max and Min, Max will always try to maximize the final value, and Min will try to minimize it. Algorithm: Mini-max12345678910111213141516171819Algorithm F(position p) //max nodeif d = 0 return f(p)else m = - INF for i = 1 to d do: t = G(pi) if t &gt; m then m = treturn mAlgorithm G(position p) //min nodeif d = 0 return f(p)else m = - INF for i = 1 to d do: t = F(pi) if t &lt; m then m = treturn m This is a brute-force method to try all possibilities. Nega-max formulationsince Max nodes will try to maximize value, Min nodes will try to minimize value. This causes some trouble.If we change the Min nodes’ value to negative, each node will maximize its value. since it’s zero sum game, the negative values are exactly the value from the Min nodes’ view. This is why Min nodes wants to maximize it. $$F(p) = \\cases{ {h(p)} &amp; {if d = 0} \\\\ {\\max \\lbrace -F(p_1), -F(p_2) , \\cdots, -F(p_d) \\rbrace } &amp; {if d &gt; 0} }$$ $$h(p) = \\cases{ {f(p)} &amp; {if depth of p is 0 or even} \\\\ {-f(p)} &amp; {if depth of p is odd}}$$ Algorithm: Nega-max123456789Algorithm F(position p)if d = 0 return f(p)else m = - INF for i = 1 to d do: t = -F(pi) if t &gt; m then m = treturn m A simpler code, Huh? Alpha-beta cut-offAlpha cut-offOn a max node.Since node 1 has the value 15, the value of the root node $\\geq$ 15. Node 2 has a child whose value is 10, so node 2 has a value $\\leq$ 10. So the root node will never choose node 2, so we don’t have to travel node 2’s children. Just cut them off like the picture shows.This is called alpha cut-off. Beta cut-offOn a min node. Deep alpha cut-offlike the picture.We can find similar properties for deep beta cut-off. Ideas for refinement $alpha$ is the current lower bound of the possible returned value; $beta$ is the current upper bound of the possible returned value; During searching, if $alpha &gt; beta$, then don’t need to search any more in this branch. Initially $alpha = -\\infty, beta = \\infty$ Alpha-beta pruning algorithmMini-max123456789101112131415161718192021Algorithm F2(position p, alpha, beta) //max nodeif d = 0 return f(p)else m = alpha for i = 1 to d do: t = G2(pi, m, beta) if t &gt; m then m = t if m &gt;= beta then return m //beta cut-offreturn mAlgorithm G2(position p, alpha, beta) //min nodeif d = 0 return f(p)else m = beta for i = 1 to d do: t = F2(pi, alpha, m) if t &lt; m then m = t if m &lt;= alpha then return mreturn m at Max node, the child’s value can change its alpha only.at Min node, the child’s value can change its beta only.From the parent to child, alpha, beta are unchanged.Initial call $F2(root, -\\infty, \\infty)$ Nega-max12345678910Algorithm F2(position p, alpha, eta)if d = 0 return f(p)else m = alpha for i = 1 to d do: t = -F(pi, -beta, -m) if t &gt; m then m = t if m &gt;= beta then return m //cut offreturn m The child’s value can only change parent’s alpha.From parent to child, parent(alpha, beta) $\\Rightarrow$ child(-beta, -alpha). It can change both. ReferenceAll above is mainly a summerize of Tsan-sheng Hsu: Alpha-Beta Pruning: Algorithm and Analysis. I add some own ideas, too.If you want to read the analysis and the proof, you can read these two articles. Tsan-sheng Hsu: Alpha-Beta Pruning: Algorithm and AnalysisD. E. Knuth and R. W. Moore. An analysis of alpha-beta pruning. Artificial Intelligence, 6:293–326, 1975.","tags":[{"name":"Alpha-beta pruning","slug":"Alpha-beta-pruning","permalink":"http://yoursite.com/tags/Alpha-beta-pruning/"},{"name":"Search","slug":"Search","permalink":"http://yoursite.com/tags/Search/"}]},{"title":"美国的政治","date":"2016-05-20T15:35:57.000Z","path":"2016/05/20/America-politics/","text":"美国区域文化与政治倾向 五大区域的开发历程与经济文化特点 各地区美国政治倾向及其在全国政坛上的影响 区域平衡与总统治理 红州、蓝州政治理念分歧 五大区域新英格兰地区的政治经济文化（自由派基地） WASP文化的大本营 WASP 革命先锋与领袖精神 深厚的经济基础 自由派政治基地 电影 Mono Lisa Smile 南方政治文化（（宗教）保守） 种植园经济与贵族文化 南北战争后经济停滞 圣经地带的保守传统 南方政影响力上升（里根革命之后） 电影 A Streetcar named desire 大湖区政治文化 （进步主义/保守主义） 制造业重镇 进步传统与保护主义倾向 锈带的兴衰 锈带-维基百科 电影 Grand Torina 中西部政治文化（（个人主义）保守） 边疆精神 新政时期 （扶助农业） 坚守传统价值观念 电影 Bridges of Madison Country 西部政治文化（多元、前卫） 阳光地带的双面经济 活跃、多样化的社会 开风气之先 上升为新的地理政治中心 电影 Crash 美国2012年总统选举 \\ 东北部 南部 大湖区 中西部 西部 Obama 11 2 5 1 7 Romney 0 8 3 9 4","tags":[{"name":"America","slug":"America","permalink":"http://yoursite.com/tags/America/"},{"name":"Politics","slug":"Politics","permalink":"http://yoursite.com/tags/Politics/"},{"name":"Introduction","slug":"Introduction","permalink":"http://yoursite.com/tags/Introduction/"}]},{"title":"美国的宗教","date":"2016-05-20T15:24:46.000Z","path":"2016/05/20/America-religion/","text":"导言《查理周刊》事件： 美国总统未参加巴黎游行 《纽约时报》：我不是查理 林达：言论自由有边界：冒犯宗教？仇恨性语言？Garland， TX 穆罕默德画展 美国宗教概况特点： 宗教色彩浓厚 God Bless America 美国第二国歌 调查： 每十位美国人九个人信仰上帝 世界宗教信仰程度 美国的宗教版图 宗教多元 多数人信仰新教 新教： 浸礼会：最大的教派，主要在南方 卫斯理会：南北两个教会，中产阶级为主，帮助穷人 长老会：大多为白人，强烈盎格鲁撒克逊特点 圣公会：富人阶级 教友会：主要在宾夕法尼亚州 天主教： 主要来自移民，比较传统，在堕胎，同性恋，干细胞研究等持保守态度。 只有一位总统：肯尼迪。 犹太教： 星期六上午去教堂。 很多著名报纸犹太人办的，《纽约时报》《华盛顿邮报》 摩门教： 《摩门经》和《圣经》 来自美国各个阶层，受教育程度相差大 犹他州较多 家谱图书馆 杨百翰大学：摩门教学校 名人：罗姆尼，洪博培 伊斯兰教： 一部分中东移民，一部分黑人移民 911之后美国社会的不信任 阿米什： 拒绝一切现代化生活和科技 美国宗教历程美国宗教走过走过400多年的历史 宗教避难所五月花号，1620. may flower compact 清教徒的专制安妮·哈钦森：被清教徒放逐塞勒姆审巫案：20多人死于此案，上百人受到监禁。 弗尼吉亚宗教自由法令杰斐逊起草。 宗教复兴：第一次，第二次大觉醒Great Awakening, Second Great Awakening.第一次：巡回布道第二次：社会变革，救济穷人，西进运动，黑人问题。促进了宗教复兴黑人教会的兴起 南北教会分裂，社会福音运动 两次世界大战之后至今反文化运动保守主义回归（1980） 美国政教关系宪法的有关规定 第六条第三段宪法第一修正案 政教分离原则 信仰自由 最高法院的裁决及对宪法的解释案例： 教会财产免税 美元：“我们信仰上帝” 校园祈祷：恩格尔诉瓦伊塔尔案（强制性祈祷违宪） 政府开会前祈祷 向国旗致敬 猴子审判案：进化论 自由的边界：韦克庄园惨案 宗教在美国生活中的作用道德源泉基督教传统价值观兴办慈善机构，如哈佛大学，普林斯顿大学，宾州大学 对美国政治外交的影响 影响政治的手段：志愿者，参与选举等 对中美关系的影响：美国传教士与近现代中国 卫三畏：美国首位来华传教士，“汉学之父” 伯贾：首位来华传教医生，长老会传教士，外交官，医生 办学：东吴大学，协和医科大学，金陵女子大学，燕京大学，辅仁大学（英美天主教合办） 人口问题 西藏问题 社会问题和文化冲突 美国人对移民看法，对穆斯林看法","tags":[{"name":"America","slug":"America","permalink":"http://yoursite.com/tags/America/"},{"name":"Introduction","slug":"Introduction","permalink":"http://yoursite.com/tags/Introduction/"},{"name":"Religion","slug":"Religion","permalink":"http://yoursite.com/tags/Religion/"}]},{"title":"生成全排列的算法","date":"2016-05-20T08:59:02.000Z","path":"2016/05/20/full-permutation/","text":"全排列 从n个不同元素中任取m（m≤n）个元素，按照一定的顺序排列起来，叫做从n个不同元素中取出m个元素的一个排列。当m=n时所有的排列情况叫全排列。 例如：如1,2,3三个元素的全排列为：(1,2,3), (1,3,2), (2,1,3), (2,3,1), (3,1,2), (3,2,1) 算法简单的递归算法next_permutation函数下面我们来解析一下STL中的next_permutation函数。 源码1234567891011121314151617181920212223242526272829template&lt;class _BidIt&gt; inline bool _Next_permutation(_BidIt _First, _BidIt _Last) &#123; // permute and test for pure ascending, using operator&lt; _DEBUG_RANGE(_First, _Last); _BidIt _Next = _Last; if (_First == _Last || _First == --_Next) return (false); //-----------------------------------------------\\ for (; ; ) &#123; // find rightmost element smaller than successor _BidIt _Next1 = _Next; if (_DEBUG_LT(*--_Next, *_Next1)) &#123; // swap with rightmost element that's smaller, flip suffix _BidIt _Mid = _Last; for (; !_DEBUG_LT(*_Next, *--_Mid); ) ; std::iter_swap(_Next, _Mid); std::reverse(_Next1, _Last); return (true); &#125; if (_Next == _First) &#123; // pure descending, flip all std::reverse(_First, _Last); return (false); &#125; &#125; &#125; 伪码描述： 从后向前找到第一个A[i] &lt; A[j] , i = j - 1 从后向前找到第一个k, 使得A[i] &lt; A[k] 交换A[i], A[k]。将j之后(包括j)的元素颠倒顺序原理：产生的下一个排列比原排列（按照字典序）大，而且不存在另外一个排列比原排列大，而比产生的排列小。原排列记作P，交换后的排列记作QP，Q在i位及以后开始不一样P在j位以后（包括j位）是降序的，意味着只改变j之后(包括j)的元素无法使序列增大。找到j位以后最小的且大于等于A[i]的数A[j]，交换位置，仍可以保证j位以后（包括j位）是降序的，然后将j之后(包括j)的元素颠倒顺序，保证j位以后（包括j位）是升序的。所以Q排列是最小的大于P排列的排列。（算法的思想是满足Q比P大的情况下使高位上的数尽可能小）","tags":[]},{"title":"NP Complete Reduction","date":"2016-05-20T02:57:14.000Z","path":"2016/05/20/NP-Complete-Reduction/","text":"$A \\propto B$ $A, B$是判定性问题，将$A$问题转化为$B$问题的一个实例，调用$B$的算法解决 $B$有解 $\\rightarrow$ $A$有解 $\\wedge$ $B$无解 $\\rightarrow$ $A$无解 只需证明可以由 $B$ 的解构造出 $A$ 的解，$A$ 的解可以构造出 $B$ 的解 $CLIQUE \\propto Node \\ Cover$ $G’$是$G$的补图$CLIQUE$: 求 大于等于$k$ 阶完全子图$Node \\ Cover$: 求小于等于 $l = |N| - k$ 的顶点覆盖集 证明：$Node \\ Cover$得到$F$, $V-F$即为$CLIQUE$的解。$G’$中的顶点覆盖集$F$对 $\\forall v_i , \\forall v_j \\in V-F$, 即 $v_i, v_j \\notin F$由于 $F$ 可以覆盖$G’$中的所有的边，但 $F$ 无法覆盖$(v_i, v_j)$所以 $(v_i, v_j) \\notin G’$即 $(v_i, v_j) \\in G$ $G$ 的完全子图 $I$ ， $V-I$ 一定是 $G’$ 的顶点覆盖集。对 $ \\forall $ 边 $ ( v_i, v_j ) \\in E(G’) $ ，则$ ( v_i, v_j ) \\notin E(G) $，则 $( v_i, v_j )$ 至少有一个不在 $I$ 中，则 $( v_i, v_j )&gt;$ 至少有一个在 $V-I$ 中，边 $( v_i, v_j )$ 可被 $V-I$ 覆盖。 $Node \\ Cover \\propto Feedback \\ Node \\ Set$$Feedback \\ Node \\ Set$ 给定有向图 $H$ ，正整数 $k$ ，问是否存在规模不超过 $k$ 的点集 $R$ ，使 $H$ 中任意一个圈至少包含 $R$ 中的一个点。 Graph $H$$V = N$$E = \\lbrace &lt; u, v &gt; | \\ (u, v) \\in E(G) \\rbrace$$k = l$即将无向边变为双向边 证明：$H$ 的点反馈集 $F$ 即是 $G$ 的顶点覆盖集对于$\\forall$ 圈 $C$ ，$\\exists$顶点 $v_i$ 属于 $F$， $v_i$ 在圈 $C$ 上对$\\forall e \\in E(G)$，$C$ 为这条边生成的圈（例如G中1-2有边，H中圈取1-2-1），有顶点 $v_i \\in F$ 在 $C$ 上，则 $v_i \\in F$ 可以覆盖这条边。 $G$ 的顶点覆盖集 $I$ 即是$H$ 的点反馈集对 $\\forall$ 的圈 $\\in H$，存在一条有向边 $&lt; v_i, v_j &gt;$ 对应的 $G$ 中的无向边 $(v_i, v_j)$ 可被 $I$ 覆盖。所以该圈至少有一个点在 $I$ 中。 $Node \\ Cover \\propto Feedback \\ Arc \\ Set$ 给定有向图 $H$ ，正整数 $k$ ，问是否存在规模不超过 $k$ 的边集 $R$ ，使 $H$ 中任意一个圈至少包含 $R$ 中的一条边。 $V = V(G) \\times \\lbrace 0, 1\\rbrace $$E = \\lbrace &lt;&lt; u,0 &gt;, &lt; u,1 &gt;&gt; | \\ u \\in V(G)\\rbrace \\cup \\lbrace &lt;&lt; u,1 &gt;, &lt; v,0 &gt;&gt; | \\ ( u,v ) \\in E(G)\\rbrace$$k = l$ 证明：构造图 $H$点分裂：将无向图每个点分裂为入点和出点，当 $i,j$ 在原无向图中构成边时，将 $i$ 的出点连有向边指向 $j$ 的入点，$j$ 的出点连有向边指向 $i$ 的入点。同时，每个点的入点指向自己的出点。分裂后的图记为$H$ ，边反馈集记为 $F$ 。 构造 $G$ 的 $Node \\ Cover$:对 $\\forall$ 边 $&lt; x_{in}, x_{out} &gt; \\vee &lt; y_{out}, x_{in} &gt; \\in F$, 将 $x$ 放入集合 $I$ 中。$I$ 即为 $G$ 的 $Node \\ Cover$. 对 $\\forall (A, B&gt; \\in E(G)$$\\Rightarrow$ 生成 $H$ 中的一个圈 $$A_{in} \\rightarrow A_{out} \\rightarrow B_{in} \\rightarrow B_{out} \\rightarrow A_{in}$$$\\Rightarrow$ 4条边至少有一条边 $\\in F$$\\Rightarrow$ $A \\in I \\vee B \\in I$$\\Rightarrow$ $&lt; A,B &gt;$可被 $I$ 中的点覆盖 由 $G$ 的 $Node \\ Cover$ 构造 $H$ 的边反馈集对 $\\forall$ 点 $x \\in I$, 边 $&lt; x_{in}, x_{out} &gt; \\in H$ 放入集合 $F$ 中。$F$ 即为 $H$ 的边反馈集 对 $\\forall$ 的圈 $\\in H$，对应 $G$ 中的一条边或一个圈，对任意一条边，存在 $v \\in I$ 使得 $v$ 可以覆盖这条边，必然存在一条有向边 $&lt; v_{in}, v_{out} &gt;$ 在圈上，该边 $ \\in F$ 。所以$F$ 即为 $H$ 的边反馈集。","tags":[{"name":"计算复杂度","slug":"计算复杂度","permalink":"http://yoursite.com/tags/计算复杂度/"},{"name":"NP完全","slug":"NP完全","permalink":"http://yoursite.com/tags/NP完全/"}]}]